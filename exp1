goal_state = [[1, 2, 3], [8, 0, 4], [7, 6, 5]]
def find_empty_tile(board):
    for i in range(3):
        for j in range(3):
            if board[i][j] == 0:
                return i, j
def manhattan_distance(tile, target):
    return abs(tile[0] - target[0]) + abs(tile[1] - target[1])
def solve_puzzle(initial_state):
    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]
    open_list = []
    closed_list = set()
    initial_position = find_empty_tile(initial_state)
    open_list.append((initial_state, initial_position, []))
    while open_list:
        current_state, empty_tile, path = open_list.pop(0)
        closed_list.add(tuple(map(tuple, current_state)))
        if current_state == goal_state:
            return path
        for move in moves:
            new_position = (empty_tile[0] + move[0], empty_tile[1] + move[1])
            if 0 <= new_position[0] < 3 and 0 <= new_position[1] < 3:
                new_state = [row[:] for row in current_state]
                new_state[empty_tile[0]][empty_tile[1]] = current_state[new_position[0]][new_position[1]]
                new_state[new_position[0]][new_position[1]] = 0
                if tuple(map(tuple, new_state)) not in closed_list:
                    new_path = path + [move]
                    open_list.append((new_state, new_position, new_path))
                    open_list.sort(key=lambda x: len(x[2]) + manhattan_distance(x[1], initial_position))
    return None
initial_state = [[2, 8, 3], [1, 6, 4], [7, 0, 5]]
solution = solve_puzzle(initial_state)
if solution:
    print("Solution found in", len(solution), "moves:")
    for move in solution:
        if move == (0, 1):
            print("Move 0 right")
        elif move == (0, -1):
            print("Move 0 left")
        elif move == (1, 0):
            print("Move 0 down")
        elif move == (-1, 0):
            print("Move 0 up")
else:
    print("No solution found.")
